# 文件锁功能 - 防止程序重复运行

## 问题
如果在多个终端窗口同时运行程序，会导致：
- 机器人控制冲突
- PLC端口冲突
- 系统行为异常

## 解决方案
✅ **已实现文件锁机制，自动防止程序重复运行**

## 效果演示

### 第一次启动（成功）
```bash
$ python main.py
日志文件: logs/error_log_20251031_143025.txt
Waiting for all connections to be ready...
正在连接 Robot A (192.168.217.100:9091)...
```
✅ 程序正常启动

### 第二次启动（失败）
在另一个终端：
```bash
$ python main.py
======================================================================
❌ 错误：程序已经在运行中！
======================================================================
正在运行的进程ID: 12345

请检查:
  1. 是否已经在另一个终端窗口运行了此程序
  2. 如果确认程序未运行，可能是上次异常退出
     解决方法: 删除锁文件 'rm robot_control.lock'
======================================================================
```
❌ 自动检测并阻止重复运行

## 使用方法

### 正常使用
**无需任何操作！** 程序已自动集成文件锁功能。

### 测试功能
```bash
python test_file_lock.py
```

### 手动处理（异常情况）
如果程序异常退出，锁文件可能残留：
```bash
# 删除锁文件
rm robot_control.lock

# 重新启动
python main.py
```

## 工作原理

1. **启动时**：创建锁文件 `robot_control.lock`，记录进程ID
2. **运行中**：其他实例无法获取锁，自动退出
3. **退出时**：自动释放锁，删除锁文件

## 技术特点

✅ **系统级锁**：使用Linux fcntl文件锁，可靠性高
✅ **自动管理**：无需手动操作，程序自动处理
✅ **异常安全**：即使崩溃也能正确清理
✅ **友好提示**：清晰的错误信息和解决方案

## 文件说明

- **`file_lock.py`** - 文件锁实现模块
- **`robot_control.lock`** - 运行时锁文件（自动创建/删除）
- **`FILE_LOCK_README.md`** - 完整技术文档
- **`test_file_lock.py`** - 功能测试脚本

## 常见问题

### Q: 如何查看程序是否在运行？
```bash
ps aux | grep main.py
# 或者
cat robot_control.lock  # 查看进程ID
```

### Q: 程序退出后还提示"已在运行"？
可能是锁文件残留，删除即可：
```bash
rm robot_control.lock
```

### Q: 想在多台电脑上同时运行？
可以！文件锁只限制同一台电脑的多个实例。

### Q: 会影响性能吗？
几乎没有影响，只在启动和退出时操作一次。

## 总结

✅ 已集成到程序中，开箱即用
✅ 完全自动，无需配置
✅ 有效防止程序重复运行
✅ 提高系统稳定性和安全性

**详细文档**: 查看 `FILE_LOCK_README.md`

